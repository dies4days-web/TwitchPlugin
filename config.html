<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Friends List Config</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {font-family: Arial, sans-serif; background:#18181b; color:#efeff1; padding:20px;}
    input {width:100%; padding:10px; margin:10px 0; background:#1f1f23; border:1px solid #9146ff; color:#fff;}
    button {background:#9146ff; color:#fff; border:none; padding:10px 20px; cursor:pointer; margin:5px;}
    button:hover {background:#7c3aed;}
    .friend {display:flex; align-items:center; background:#1f1f23; padding:10px; margin:10px 0;}
    .friend img {border-radius:50%; width:48px; height:48px; margin-right:10px;}
    .friend span {flex:1;}
    .warning {color:#ff6b6b; padding:10px; border:1px solid #ff4d4d; border-radius:4px; margin:10px 0;}
  </style>
</head>
<body>
  <h1>Friends List Config</h1>
  <div id="warning" style="display:none;" class="warning">Running in fallback mode (no Twitch context) - limited functionality</div>
  <input type="text" id="username" placeholder="Twitch username (exact login name)" />
  <button id="add">Add Friend</button>
  <div id="list"></div>
  <button id="save">Save & Close</button>

  <script>
    const clientId = 'v52hn2spd1ldo2zo34iv91xtkoo98s';
    const listEl = document.getElementById('list');
    const addBtn = document.getElementById('add');
    const saveBtn = document.getElementById('save');
    const warningEl = document.getElementById('warning');
    let friends = [];
    let helixToken = null;
    let isTwitchContext = typeof Twitch !== 'undefined' && Twitch.ext;

    if (!isTwitchContext) {
      warningEl.style.display = 'block';
    }

    function render() {
      listEl.innerHTML = '';
      friends.forEach((f, i) => {
        const div = document.createElement('div');
        div.className = 'friend';
        div.innerHTML = `
          <img src="${f.profile_image_url || 'https://static-cdn.jtvnw.net/ttv-static/404_preview-48x48.png'}" alt="${f.display_name}">
          <span>${f.display_name} (${f.login})</span>
          <button data-index="${i}" style="background:#6441a5;">Remove</button>
        `;
        div.querySelector('button').onclick = () => {
          friends.splice(i, 1);
          render();
        };
        listEl.appendChild(div);
      });
    }

    addBtn.onclick = async () => {
      const login = document.getElementById('username').value.trim().toLowerCase();
      if (!login) return;
      if (!isTwitchContext || !helixToken) {
        alert('No Twitch context - adding dummy user');
        friends.push({
          id: Date.now().toString(),
          login: login,
          display_name: login.charAt(0).toUpperCase() + login.slice(1),
          profile_image_url: 'https://static-cdn.jtvnw.net/ttv-static/404_preview-300x300.png'
        });
        render();
        document.getElementById('username').value = '';
        return;
      }
      try {
        const res = await fetch(`https://api.twitch.tv/helix/users?login=${login}`, {
          headers: { 'Client-ID': clientId, 'Authorization': `Bearer ${helixToken}` }
        });
        if (res.status === 401) {
          alert('Unauthorized - check token');
          return;
        }
        const data = await res.json();
        if (data.data && data.data[0]) {
          const user = data.data[0];
          if (!friends.find(f => f.id === user.id)) {
            friends.push({
              id: user.id,
              login: user.login,
              display_name: user.display_name,
              profile_image_url: user.profile_image_url
            });
            render();
          }
        } else {
          alert('User not found');
        }
      } catch (e) { alert('Error: ' + e.message); }
      document.getElementById('username').value = '';
    };

    saveBtn.onclick = () => {
      if (!isTwitchContext) {
        localStorage.setItem('twitch-friends-backup', JSON.stringify({ friends }));
        alert('Saved to local storage (fallback) - will work for testing');
        return;
      }
      Twitch.ext.configuration.set('broadcaster', '1.0', JSON.stringify({ friends }));
      alert('Saved!');
    };

    if (isTwitchContext) {
      Twitch.ext.configuration.onChanged(() => {
        if (Twitch.ext.configuration.broadcaster) {
          try {
            const cfg = JSON.parse(Twitch.ext.configuration.broadcaster.content);
            if (cfg.friends) friends = cfg.friends;
            render();
          } catch (e) { alert('Config parse error'); }
        }
      });

      Twitch.ext.onAuthorized((auth) => {
        helixToken = auth.helixToken;
      });

      Twitch.ext.onError((e) => alert('Twitch error: ' + e));
    } else {
      const saved = localStorage.getItem('twitch-friends-backup');
      if (saved) {
        try {
          const cfg = JSON.parse(saved);
          if (cfg.friends) friends = cfg.friends;
          render();
        } catch (e) {}
      }
    }
  </script>
</body>
</html>
